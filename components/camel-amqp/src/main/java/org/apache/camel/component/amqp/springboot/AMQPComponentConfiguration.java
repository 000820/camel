/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.amqp.springboot;

import javax.jms.ConnectionFactory;
import javax.jms.ExceptionListener;
import org.apache.camel.LoggingLevel;
import org.apache.camel.component.jms.DefaultTaskExecutorType;
import org.apache.camel.component.jms.JmsConfiguration;
import org.apache.camel.component.jms.JmsKeyFormatStrategy;
import org.apache.camel.component.jms.MessageCreatedStrategy;
import org.apache.camel.component.jms.QueueBrowseStrategy;
import org.apache.camel.component.jms.ReplyToType;
import org.apache.camel.spi.HeaderFilterStrategy;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.util.ErrorHandler;

/**
 * Messaging with AMQP protocol using Apache QPid Client.
 * 
 * Generated by camel-package-maven-plugin - do not edit this file!
 */
@ConfigurationProperties(prefix = "camel.component.amqp")
public class AMQPComponentConfiguration {

    /**
     * To use a shared JMS configuration
     */
    private JmsConfiguration configuration;
    /**
     * Specifies whether the consumer accept messages while it is stopping. You
     * may consider enabling this option if you start and stop JMS routes at
     * runtime while there are still messages enqued on the queue. If this
     * option is false and you stop the JMS route then messages may be rejected
     * and the JMS broker would have to attempt redeliveries which yet again may
     * be rejected and eventually the message may be moved at a dead letter
     * queue on the JMS broker. To avoid this its recommended to enable this
     * option.
     */
    private boolean acceptMessagesWhileStopping;
    /**
     * Whether the DefaultMessageListenerContainer used in the reply managers
     * for request-reply messaging allow the
     * DefaultMessageListenerContainer.runningAllowed flag to quick stop in case
     * JmsConfigurationisAcceptMessagesWhileStopping is enabled and
     * org.apache.camel.CamelContext is currently being stopped. This quick stop
     * ability is enabled by default in the regular JMS consumers but to enable
     * for reply managers you must enable this flag.
     */
    private boolean allowReplyManagerQuickStop;
    /**
     * The JMS acknowledgement mode defined as an Integer. Allows you to set
     * vendor-specific extensions to the acknowledgment mode. For the regular
     * modes it is preferable to use the acknowledgementModeName instead.
     */
    private int acknowledgementMode;
    /**
     * Enables eager loading of JMS properties as soon as a message is loaded
     * which generally is inefficient as the JMS properties may not be required
     * but sometimes can catch early any issues with the underlying JMS provider
     * and the use of JMS properties
     */
    private boolean eagerLoadingOfProperties;
    /**
     * The JMS acknowledgement name which is one of: SESSION_TRANSACTED
     * CLIENT_ACKNOWLEDGE AUTO_ACKNOWLEDGE DUPS_OK_ACKNOWLEDGE
     */
    private String acknowledgementModeName;
    /**
     * Specifies whether the consumer container should auto-startup.
     */
    private boolean autoStartup;
    /**
     * Sets the cache level by ID for the underlying JMS resources. See
     * cacheLevelName option for more details.
     */
    private int cacheLevel;
    /**
     * Sets the cache level by name for the underlying JMS resources. Possible
     * values are: CACHE_AUTO CACHE_CONNECTION CACHE_CONSUMER CACHE_NONE and
     * CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring
     * documentation and Transactions Cache Levels for more information.
     */
    private String cacheLevelName;
    /**
     * Sets the cache level by name for the reply consumer when doing
     * request/reply over JMS. This option only applies when using fixed reply
     * queues (not temporary). Camel will by default use: CACHE_CONSUMER for
     * exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared
     * without replyToSelectorName. Some JMS brokers such as IBM WebSphere may
     * require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If
     * using temporary queues then CACHE_NONE is not allowed and you must use a
     * higher value such as CACHE_CONSUMER or CACHE_SESSION.
     */
    private String replyToCacheLevelName;
    /**
     * Sets the JMS client ID to use. Note that this value if specified must be
     * unique and can only be used by a single JMS connection instance. It is
     * typically only required for durable topic subscriptions. If using Apache
     * ActiveMQ you may prefer to use Virtual Topics instead.
     */
    private String clientId;
    /**
     * Specifies the default number of concurrent consumers when consuming from
     * JMS (not for request/reply over JMS). See also the maxMessagesPerTask
     * option to control dynamic scaling up/down of threads. When doing
     * request/reply over JMS then the option replyToConcurrentConsumers is used
     * to control number of concurrent consumers on the reply message listener.
     */
    private int concurrentConsumers;
    /**
     * Specifies the default number of concurrent consumers when doing
     * request/reply over JMS. See also the maxMessagesPerTask option to control
     * dynamic scaling up/down of threads.
     */
    private int replyToConcurrentConsumers;
    /**
     * Sets the default connection factory to be use
     */
    private ConnectionFactory connectionFactory;
    /**
     * Specifies whether persistent delivery is used by default.
     */
    private boolean deliveryPersistent;
    /**
     * Specifies the delivery mode to be used. Possible values are Possibles
     * values are those defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1
     * and PERSISTENT = 2.
     */
    private Integer deliveryMode;
    /**
     * The durable subscriber name for specifying durable topic subscriptions.
     * The clientId option must be configured as well.
     */
    private String durableSubscriptionName;
    /**
     * Specifies the JMS Exception Listener that is to be notified of any
     * underlying JMS exceptions.
     */
    private ExceptionListener exceptionListener;
    /**
     * Specifies a org.springframework.util.ErrorHandler to be invoked in case
     * of any uncaught exceptions thrown while processing a Message. By default
     * these exceptions will be logged at the WARN level if no errorHandler has
     * been configured. You can configure logging level and whether stack traces
     * should be logged using errorHandlerLoggingLevel and
     * errorHandlerLogStackTrace options. This makes it much easier to configure
     * than having to code a custom errorHandler.
     */
    private ErrorHandler errorHandler;
    /**
     * Allows to configure the default errorHandler logging level for logging
     * uncaught exceptions.
     */
    private LoggingLevel errorHandlerLoggingLevel;
    /**
     * Allows to control whether stacktraces should be logged or not by the
     * default errorHandler.
     */
    private boolean errorHandlerLogStackTrace;
    /**
     * Set if the deliveryMode priority or timeToLive qualities of service
     * should be used when sending messages. This option is based on Spring's
     * JmsTemplate. The deliveryMode priority and timeToLive options are applied
     * to the current endpoint. This contrasts with the preserveMessageQos
     * option which operates at message granularity reading QoS properties
     * exclusively from the Camel In message headers.
     */
    private boolean explicitQosEnabled;
    /**
     * Specifies whether the listener session should be exposed when consuming
     * messages.
     */
    private boolean exposeListenerSession;
    /**
     * Specifies the limit for idle executions of a receive task not having
     * received any message within its execution. If this limit is reached the
     * task will shut down and leave receiving to other executing tasks (in the
     * case of dynamic scheduling; see the maxConcurrentConsumers setting).
     * There is additional doc available from Spring.
     */
    private int idleTaskExecutionLimit;
    /**
     * Specify the limit for the number of consumers that are allowed to be idle
     * at any given time.
     */
    private int idleConsumerLimit;
    /**
     * Specifies the maximum number of concurrent consumers when consuming from
     * JMS (not for request/reply over JMS). See also the maxMessagesPerTask
     * option to control dynamic scaling up/down of threads. When doing
     * request/reply over JMS then the option replyToMaxConcurrentConsumers is
     * used to control number of concurrent consumers on the reply message
     * listener.
     */
    private int maxConcurrentConsumers;
    /**
     * Specifies the maximum number of concurrent consumers when using
     * request/reply over JMS. See also the maxMessagesPerTask option to control
     * dynamic scaling up/down of threads.
     */
    private int replyToMaxConcurrentConsumers;
    /**
     * Specifies the maximum number of concurrent consumers for continue routing
     * when timeout occurred when using request/reply over JMS.
     */
    private int replyOnTimeoutToMaxConcurrentConsumers;
    /**
     * The number of messages per task. -1 is unlimited. If you use a range for
     * concurrent consumers (eg min max) then this option can be used to set a
     * value to eg 100 to control how fast the consumers will shrink when less
     * work is required.
     */
    private int maxMessagesPerTask;
    /**
     * To use a custom Spring
     * org.springframework.jms.support.converter.MessageConverter so you can be
     * in control how to map to/from a javax.jms.Message.
     */
    private MessageConverter messageConverter;
    /**
     * Specifies whether Camel should auto map the received JMS message to a
     * suited payload type such as javax.jms.TextMessage to a String etc. See
     * section about how mapping works below for more details.
     */
    private boolean mapJmsMessage;
    /**
     * When sending specifies whether message IDs should be added.
     */
    private boolean messageIdEnabled;
    /**
     * Specifies whether timestamps should be enabled by default on sending
     * messages.
     */
    private boolean messageTimestampEnabled;
    /**
     * If true Camel will always make a JMS message copy of the message when it
     * is passed to the producer for sending. Copying the message is needed in
     * some situations such as when a replyToDestinationSelectorName is set
     * (incidentally Camel will set the alwaysCopyMessage option to true if a
     * replyToDestinationSelectorName is set)
     */
    private boolean alwaysCopyMessage;
    /**
     * Specifies whether JMSMessageID should always be used as JMSCorrelationID
     * for InOut messages.
     */
    private boolean useMessageIDAsCorrelationID;
    /**
     * Values greater than 1 specify the message priority when sending (where 0
     * is the lowest priority and 9 is the highest). The explicitQosEnabled
     * option must also be enabled in order for this option to have any effect.
     */
    private int priority;
    /**
     * Specifies whether to inhibit the delivery of messages published by its
     * own connection.
     */
    private boolean pubSubNoLocal;
    /**
     * The timeout for receiving messages (in milliseconds).
     */
    private long receiveTimeout;
    /**
     * Specifies the interval between recovery attempts i.e. when a connection
     * is being refreshed in milliseconds. The default is 5000 ms that is 5
     * seconds.
     */
    private long recoveryInterval;
    /**
     * Deprecated: Enabled by default if you specify a durableSubscriptionName
     * and a clientId.
     */
    @Deprecated
    private boolean subscriptionDurable;
    /**
     * Allows you to specify a custom task executor for consuming messages.
     */
    private TaskExecutor taskExecutor;
    /**
     * When sending messages specifies the time-to-live of the message (in
     * milliseconds).
     */
    private long timeToLive;
    /**
     * Specifies whether to use transacted mode
     */
    private boolean transacted;
    /**
     * If true Camel will create a JmsTransactionManager if there is no
     * transactionManager injected when option transacted=true.
     */
    private boolean lazyCreateTransactionManager;
    /**
     * The Spring transaction manager to use.
     */
    private PlatformTransactionManager transactionManager;
    /**
     * The name of the transaction to use.
     */
    private String transactionName;
    /**
     * The timeout value of the transaction (in seconds) if using transacted
     * mode.
     */
    private int transactionTimeout;
    /**
     * Specifies whether to test the connection on startup. This ensures that
     * when Camel starts that all the JMS consumers have a valid connection to
     * the JMS broker. If a connection cannot be granted then Camel throws an
     * exception on startup. This ensures that Camel is not started with failed
     * connections. The JMS producers is tested as well.
     */
    private boolean testConnectionOnStartup;
    /**
     * Whether to startup the JmsConsumer message listener asynchronously when
     * starting a route. For example if a JmsConsumer cannot get a connection to
     * a remote JMS broker then it may block while retrying and/or failover.
     * This will cause Camel to block while starting routes. By setting this
     * option to true you will let routes startup while the JmsConsumer connects
     * to the JMS broker using a dedicated thread in asynchronous mode. If this
     * option is used then beware that if the connection could not be
     * established then an exception is logged at WARN level and the consumer
     * will not be able to receive messages; You can then restart the route to
     * retry.
     */
    private boolean asyncStartListener;
    /**
     * Whether to stop the JmsConsumer message listener asynchronously when
     * stopping a route.
     */
    private boolean asyncStopListener;
    /**
     * When using mapJmsMessage=false Camel will create a new JMS message to
     * send to a new JMS destination if you touch the headers (get or set)
     * during the route. Set this option to true to force Camel to send the
     * original JMS message that was received.
     */
    private boolean forceSendOriginalMessage;
    /**
     * The timeout for waiting for a reply when using the InOut Exchange Pattern
     * (in milliseconds). The default is 20 seconds. You can include the header
     * CamelJmsRequestTimeout to override this endpoint configured timeout value
     * and thus have per message individual timeout values. See also the
     * requestTimeoutCheckerInterval option.
     */
    private long requestTimeout;
    /**
     * Configures how often Camel should check for timed out Exchanges when
     * doing request/reply over JMS. By default Camel checks once per second.
     * But if you must react faster when a timeout occurs then you can lower
     * this interval to check more frequently. The timeout is determined by the
     * option requestTimeout.
     */
    private long requestTimeoutCheckerInterval;
    /**
     * You can transfer the exchange over the wire instead of just the body and
     * headers. The following fields are transferred: In body Out body Fault
     * body In headers Out headers Fault headers exchange properties exchange
     * exception. This requires that the objects are serializable. Camel will
     * exclude any non-serializable objects and log it at WARN level. You must
     * enable this option on both the producer and consumer side so Camel knows
     * the payloads is an Exchange and not a regular payload.
     */
    private boolean transferExchange;
    /**
     * If enabled and you are using Request Reply messaging (InOut) and an
     * Exchange failed on the consumer side then the caused Exception will be
     * send back in response as a javax.jms.ObjectMessage. If the client is
     * Camel the returned Exception is rethrown. This allows you to use Camel
     * JMS as a bridge in your routing - for example using persistent queues to
     * enable robust routing. Notice that if you also have transferExchange
     * enabled this option takes precedence. The caught exception is required to
     * be serializable. The original Exception on the consumer side can be
     * wrapped in an outer exception such as
     * org.apache.camel.RuntimeCamelException when returned to the producer.
     */
    private boolean transferException;
    /**
     * If enabled and you are using Request Reply messaging (InOut) and an
     * Exchange failed with a SOAP fault (not exception) on the consumer side
     * then the fault flag on link org.apache.camel.MessageisFault() will be
     * send back in the response as a JMS header with the key link
     * JmsConstantsJMS_TRANSFER_FAULT. If the client is Camel the returned fault
     * flag will be set on the link org.apache.camel.MessagesetFault(boolean).
     * You may want to enable this when using Camel components that support
     * faults such as SOAP based such as cxf or spring-ws.
     */
    private boolean transferFault;
    /**
     * Allows you to use your own implementation of the
     * org.springframework.jms.core.JmsOperations interface. Camel uses
     * JmsTemplate as default. Can be used for testing purpose but not used much
     * as stated in the spring API docs.
     */
    private JmsOperations jmsOperations;
    /**
     * A pluggable
     * org.springframework.jms.support.destination.DestinationResolver that
     * allows you to use your own resolver (for example to lookup the real
     * destination in a JNDI registry).
     */
    private DestinationResolver destinationResolver;
    /**
     * Allows for explicitly specifying which kind of strategy to use for
     * replyTo queues when doing request/reply over JMS. Possible values are:
     * Temporary Shared or Exclusive. By default Camel will use temporary
     * queues. However if replyTo has been configured then Shared is used by
     * default. This option allows you to use exclusive queues instead of shared
     * ones. See Camel JMS documentation for more details and especially the
     * notes about the implications if running in a clustered environment and
     * the fact that Shared reply queues has lower performance than its
     * alternatives Temporary and Exclusive.
     */
    private ReplyToType replyToType;
    /**
     * Set to true if you want to send message using the QoS settings specified
     * on the message instead of the QoS settings on the JMS endpoint. The
     * following three headers are considered JMSPriority JMSDeliveryMode and
     * JMSExpiration. You can provide all or only some of them. If not provided
     * Camel will fall back to use the values from the endpoint instead. So when
     * using this option the headers override the values from the endpoint. The
     * explicitQosEnabled option by contrast will only use options set on the
     * endpoint and not values from the message header.
     */
    private boolean preserveMessageQos;
    /**
     * Whether the JmsConsumer processes the Exchange asynchronously. If enabled
     * then the JmsConsumer may pickup the next message from the JMS queue while
     * the previous message is being processed asynchronously (by the
     * Asynchronous Routing Engine). This means that messages may be processed
     * not 100 strictly in order. If disabled (as default) then the Exchange is
     * fully processed before the JmsConsumer will pickup the next message from
     * the JMS queue. Note if transacted has been enabled then
     * asyncConsumer=true does not run asynchronously as transaction must be
     * executed synchronously (Camel 3.0 may support async transactions).
     */
    private boolean asyncConsumer;
    /**
     * Whether to allow sending messages with no body. If this option is false
     * and the message body is null then an JMSException is thrown.
     */
    private boolean allowNullBody;
    /**
     * Only applicable when sending to JMS destination using InOnly (eg fire and
     * forget). Enabling this option will enrich the Camel Exchange with the
     * actual JMSMessageID that was used by the JMS client when the message was
     * sent to the JMS destination.
     */
    private boolean includeSentJMSMessageID;
    /**
     * Whether to include all JMSXxxx properties when mapping from JMS to Camel
     * Message. Setting this to true will include properties such as JMSXAppID
     * and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy
     * then this option does not apply.
     */
    private boolean includeAllJMSXProperties;
    /**
     * Specifies what default TaskExecutor type to use in the
     * DefaultMessageListenerContainer for both consumer endpoints and the
     * ReplyTo consumer of producer endpoints. Possible values: SimpleAsync
     * (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's
     * ThreadPoolTaskExecutor with optimal values - cached threadpool-like). If
     * not set it defaults to the previous behaviour which uses a cached thread
     * pool for consumer endpoints and SimpleAsync for reply consumers. The use
     * of ThreadPool is recommended to reduce thread trash in elastic
     * configurations with dynamically increasing and decreasing concurrent
     * consumers.
     */
    private DefaultTaskExecutorType defaultTaskExecutorType;
    /**
     * Pluggable strategy for encoding and decoding JMS keys so they can be
     * compliant with the JMS specification. Camel provides two implementations
     * out of the box: default and passthrough. The default strategy will safely
     * marshal dots and hyphens (. and -). The passthrough strategy leaves the
     * key as is. Can be used for JMS brokers which do not care whether JMS
     * header keys contain illegal characters. You can provide your own
     * implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy
     * and refer to it using the notation.
     */
    private JmsKeyFormatStrategy jmsKeyFormatStrategy;
    /**
     * Sets the Spring ApplicationContext to use
     */
    private ApplicationContext applicationContext;
    /**
     * To use a custom QueueBrowseStrategy when browsing queues
     */
    private QueueBrowseStrategy queueBrowseStrategy;
    /**
     * To use a custom HeaderFilterStrategy to filter header to and from Camel
     * message.
     */
    private HeaderFilterStrategy headerFilterStrategy;
    /**
     * To use the given MessageCreatedStrategy which are invoked when Camel
     * creates new instances of javax.jms.Message objects when Camel is sending
     * a JMS message.
     */
    private MessageCreatedStrategy messageCreatedStrategy;
    /**
     * Number of times to wait for provisional correlation id to be updated to
     * the actual correlation id when doing request/reply over JMS and when the
     * option useMessageIDAsCorrelationID is enabled.
     */
    private int waitForProvisionCorrelationToBeUpdatedCounter;
    /**
     * Interval in millis to sleep each time while waiting for provisional
     * correlation id to be updated.
     */
    private long waitForProvisionCorrelationToBeUpdatedThreadSleepingTime;

    public JmsConfiguration getConfiguration() {
        return configuration;
    }

    public void setConfiguration(JmsConfiguration configuration) {
        this.configuration = configuration;
    }

    public boolean isAcceptMessagesWhileStopping() {
        return acceptMessagesWhileStopping;
    }

    public void setAcceptMessagesWhileStopping(
            boolean acceptMessagesWhileStopping) {
        this.acceptMessagesWhileStopping = acceptMessagesWhileStopping;
    }

    public boolean isAllowReplyManagerQuickStop() {
        return allowReplyManagerQuickStop;
    }

    public void setAllowReplyManagerQuickStop(boolean allowReplyManagerQuickStop) {
        this.allowReplyManagerQuickStop = allowReplyManagerQuickStop;
    }

    public int getAcknowledgementMode() {
        return acknowledgementMode;
    }

    public void setAcknowledgementMode(int acknowledgementMode) {
        this.acknowledgementMode = acknowledgementMode;
    }

    public boolean isEagerLoadingOfProperties() {
        return eagerLoadingOfProperties;
    }

    public void setEagerLoadingOfProperties(boolean eagerLoadingOfProperties) {
        this.eagerLoadingOfProperties = eagerLoadingOfProperties;
    }

    public String getAcknowledgementModeName() {
        return acknowledgementModeName;
    }

    public void setAcknowledgementModeName(String acknowledgementModeName) {
        this.acknowledgementModeName = acknowledgementModeName;
    }

    public boolean isAutoStartup() {
        return autoStartup;
    }

    public void setAutoStartup(boolean autoStartup) {
        this.autoStartup = autoStartup;
    }

    public int getCacheLevel() {
        return cacheLevel;
    }

    public void setCacheLevel(int cacheLevel) {
        this.cacheLevel = cacheLevel;
    }

    public String getCacheLevelName() {
        return cacheLevelName;
    }

    public void setCacheLevelName(String cacheLevelName) {
        this.cacheLevelName = cacheLevelName;
    }

    public String getReplyToCacheLevelName() {
        return replyToCacheLevelName;
    }

    public void setReplyToCacheLevelName(String replyToCacheLevelName) {
        this.replyToCacheLevelName = replyToCacheLevelName;
    }

    public String getClientId() {
        return clientId;
    }

    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    public int getConcurrentConsumers() {
        return concurrentConsumers;
    }

    public void setConcurrentConsumers(int concurrentConsumers) {
        this.concurrentConsumers = concurrentConsumers;
    }

    public int getReplyToConcurrentConsumers() {
        return replyToConcurrentConsumers;
    }

    public void setReplyToConcurrentConsumers(int replyToConcurrentConsumers) {
        this.replyToConcurrentConsumers = replyToConcurrentConsumers;
    }

    public ConnectionFactory getConnectionFactory() {
        return connectionFactory;
    }

    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }

    public boolean isDeliveryPersistent() {
        return deliveryPersistent;
    }

    public void setDeliveryPersistent(boolean deliveryPersistent) {
        this.deliveryPersistent = deliveryPersistent;
    }

    public Integer getDeliveryMode() {
        return deliveryMode;
    }

    public void setDeliveryMode(Integer deliveryMode) {
        this.deliveryMode = deliveryMode;
    }

    public String getDurableSubscriptionName() {
        return durableSubscriptionName;
    }

    public void setDurableSubscriptionName(String durableSubscriptionName) {
        this.durableSubscriptionName = durableSubscriptionName;
    }

    public ExceptionListener getExceptionListener() {
        return exceptionListener;
    }

    public void setExceptionListener(ExceptionListener exceptionListener) {
        this.exceptionListener = exceptionListener;
    }

    public ErrorHandler getErrorHandler() {
        return errorHandler;
    }

    public void setErrorHandler(ErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }

    public LoggingLevel getErrorHandlerLoggingLevel() {
        return errorHandlerLoggingLevel;
    }

    public void setErrorHandlerLoggingLevel(
            LoggingLevel errorHandlerLoggingLevel) {
        this.errorHandlerLoggingLevel = errorHandlerLoggingLevel;
    }

    public boolean isErrorHandlerLogStackTrace() {
        return errorHandlerLogStackTrace;
    }

    public void setErrorHandlerLogStackTrace(boolean errorHandlerLogStackTrace) {
        this.errorHandlerLogStackTrace = errorHandlerLogStackTrace;
    }

    public boolean isExplicitQosEnabled() {
        return explicitQosEnabled;
    }

    public void setExplicitQosEnabled(boolean explicitQosEnabled) {
        this.explicitQosEnabled = explicitQosEnabled;
    }

    public boolean isExposeListenerSession() {
        return exposeListenerSession;
    }

    public void setExposeListenerSession(boolean exposeListenerSession) {
        this.exposeListenerSession = exposeListenerSession;
    }

    public int getIdleTaskExecutionLimit() {
        return idleTaskExecutionLimit;
    }

    public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {
        this.idleTaskExecutionLimit = idleTaskExecutionLimit;
    }

    public int getIdleConsumerLimit() {
        return idleConsumerLimit;
    }

    public void setIdleConsumerLimit(int idleConsumerLimit) {
        this.idleConsumerLimit = idleConsumerLimit;
    }

    public int getMaxConcurrentConsumers() {
        return maxConcurrentConsumers;
    }

    public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
        this.maxConcurrentConsumers = maxConcurrentConsumers;
    }

    public int getReplyToMaxConcurrentConsumers() {
        return replyToMaxConcurrentConsumers;
    }

    public void setReplyToMaxConcurrentConsumers(
            int replyToMaxConcurrentConsumers) {
        this.replyToMaxConcurrentConsumers = replyToMaxConcurrentConsumers;
    }

    public int getReplyOnTimeoutToMaxConcurrentConsumers() {
        return replyOnTimeoutToMaxConcurrentConsumers;
    }

    public void setReplyOnTimeoutToMaxConcurrentConsumers(
            int replyOnTimeoutToMaxConcurrentConsumers) {
        this.replyOnTimeoutToMaxConcurrentConsumers = replyOnTimeoutToMaxConcurrentConsumers;
    }

    public int getMaxMessagesPerTask() {
        return maxMessagesPerTask;
    }

    public void setMaxMessagesPerTask(int maxMessagesPerTask) {
        this.maxMessagesPerTask = maxMessagesPerTask;
    }

    public MessageConverter getMessageConverter() {
        return messageConverter;
    }

    public void setMessageConverter(MessageConverter messageConverter) {
        this.messageConverter = messageConverter;
    }

    public boolean isMapJmsMessage() {
        return mapJmsMessage;
    }

    public void setMapJmsMessage(boolean mapJmsMessage) {
        this.mapJmsMessage = mapJmsMessage;
    }

    public boolean isMessageIdEnabled() {
        return messageIdEnabled;
    }

    public void setMessageIdEnabled(boolean messageIdEnabled) {
        this.messageIdEnabled = messageIdEnabled;
    }

    public boolean isMessageTimestampEnabled() {
        return messageTimestampEnabled;
    }

    public void setMessageTimestampEnabled(boolean messageTimestampEnabled) {
        this.messageTimestampEnabled = messageTimestampEnabled;
    }

    public boolean isAlwaysCopyMessage() {
        return alwaysCopyMessage;
    }

    public void setAlwaysCopyMessage(boolean alwaysCopyMessage) {
        this.alwaysCopyMessage = alwaysCopyMessage;
    }

    public boolean isUseMessageIDAsCorrelationID() {
        return useMessageIDAsCorrelationID;
    }

    public void setUseMessageIDAsCorrelationID(
            boolean useMessageIDAsCorrelationID) {
        this.useMessageIDAsCorrelationID = useMessageIDAsCorrelationID;
    }

    public int getPriority() {
        return priority;
    }

    public void setPriority(int priority) {
        this.priority = priority;
    }

    public boolean isPubSubNoLocal() {
        return pubSubNoLocal;
    }

    public void setPubSubNoLocal(boolean pubSubNoLocal) {
        this.pubSubNoLocal = pubSubNoLocal;
    }

    public long getReceiveTimeout() {
        return receiveTimeout;
    }

    public void setReceiveTimeout(long receiveTimeout) {
        this.receiveTimeout = receiveTimeout;
    }

    public long getRecoveryInterval() {
        return recoveryInterval;
    }

    public void setRecoveryInterval(long recoveryInterval) {
        this.recoveryInterval = recoveryInterval;
    }

    public boolean isSubscriptionDurable() {
        return subscriptionDurable;
    }

    public void setSubscriptionDurable(boolean subscriptionDurable) {
        this.subscriptionDurable = subscriptionDurable;
    }

    public TaskExecutor getTaskExecutor() {
        return taskExecutor;
    }

    public void setTaskExecutor(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }

    public long getTimeToLive() {
        return timeToLive;
    }

    public void setTimeToLive(long timeToLive) {
        this.timeToLive = timeToLive;
    }

    public boolean isTransacted() {
        return transacted;
    }

    public void setTransacted(boolean transacted) {
        this.transacted = transacted;
    }

    public boolean isLazyCreateTransactionManager() {
        return lazyCreateTransactionManager;
    }

    public void setLazyCreateTransactionManager(
            boolean lazyCreateTransactionManager) {
        this.lazyCreateTransactionManager = lazyCreateTransactionManager;
    }

    public PlatformTransactionManager getTransactionManager() {
        return transactionManager;
    }

    public void setTransactionManager(
            PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

    public String getTransactionName() {
        return transactionName;
    }

    public void setTransactionName(String transactionName) {
        this.transactionName = transactionName;
    }

    public int getTransactionTimeout() {
        return transactionTimeout;
    }

    public void setTransactionTimeout(int transactionTimeout) {
        this.transactionTimeout = transactionTimeout;
    }

    public boolean isTestConnectionOnStartup() {
        return testConnectionOnStartup;
    }

    public void setTestConnectionOnStartup(boolean testConnectionOnStartup) {
        this.testConnectionOnStartup = testConnectionOnStartup;
    }

    public boolean isAsyncStartListener() {
        return asyncStartListener;
    }

    public void setAsyncStartListener(boolean asyncStartListener) {
        this.asyncStartListener = asyncStartListener;
    }

    public boolean isAsyncStopListener() {
        return asyncStopListener;
    }

    public void setAsyncStopListener(boolean asyncStopListener) {
        this.asyncStopListener = asyncStopListener;
    }

    public boolean isForceSendOriginalMessage() {
        return forceSendOriginalMessage;
    }

    public void setForceSendOriginalMessage(boolean forceSendOriginalMessage) {
        this.forceSendOriginalMessage = forceSendOriginalMessage;
    }

    public long getRequestTimeout() {
        return requestTimeout;
    }

    public void setRequestTimeout(long requestTimeout) {
        this.requestTimeout = requestTimeout;
    }

    public long getRequestTimeoutCheckerInterval() {
        return requestTimeoutCheckerInterval;
    }

    public void setRequestTimeoutCheckerInterval(
            long requestTimeoutCheckerInterval) {
        this.requestTimeoutCheckerInterval = requestTimeoutCheckerInterval;
    }

    public boolean isTransferExchange() {
        return transferExchange;
    }

    public void setTransferExchange(boolean transferExchange) {
        this.transferExchange = transferExchange;
    }

    public boolean isTransferException() {
        return transferException;
    }

    public void setTransferException(boolean transferException) {
        this.transferException = transferException;
    }

    public boolean isTransferFault() {
        return transferFault;
    }

    public void setTransferFault(boolean transferFault) {
        this.transferFault = transferFault;
    }

    public JmsOperations getJmsOperations() {
        return jmsOperations;
    }

    public void setJmsOperations(JmsOperations jmsOperations) {
        this.jmsOperations = jmsOperations;
    }

    public DestinationResolver getDestinationResolver() {
        return destinationResolver;
    }

    public void setDestinationResolver(DestinationResolver destinationResolver) {
        this.destinationResolver = destinationResolver;
    }

    public ReplyToType getReplyToType() {
        return replyToType;
    }

    public void setReplyToType(ReplyToType replyToType) {
        this.replyToType = replyToType;
    }

    public boolean isPreserveMessageQos() {
        return preserveMessageQos;
    }

    public void setPreserveMessageQos(boolean preserveMessageQos) {
        this.preserveMessageQos = preserveMessageQos;
    }

    public boolean isAsyncConsumer() {
        return asyncConsumer;
    }

    public void setAsyncConsumer(boolean asyncConsumer) {
        this.asyncConsumer = asyncConsumer;
    }

    public boolean isAllowNullBody() {
        return allowNullBody;
    }

    public void setAllowNullBody(boolean allowNullBody) {
        this.allowNullBody = allowNullBody;
    }

    public boolean isIncludeSentJMSMessageID() {
        return includeSentJMSMessageID;
    }

    public void setIncludeSentJMSMessageID(boolean includeSentJMSMessageID) {
        this.includeSentJMSMessageID = includeSentJMSMessageID;
    }

    public boolean isIncludeAllJMSXProperties() {
        return includeAllJMSXProperties;
    }

    public void setIncludeAllJMSXProperties(boolean includeAllJMSXProperties) {
        this.includeAllJMSXProperties = includeAllJMSXProperties;
    }

    public DefaultTaskExecutorType getDefaultTaskExecutorType() {
        return defaultTaskExecutorType;
    }

    public void setDefaultTaskExecutorType(
            DefaultTaskExecutorType defaultTaskExecutorType) {
        this.defaultTaskExecutorType = defaultTaskExecutorType;
    }

    public JmsKeyFormatStrategy getJmsKeyFormatStrategy() {
        return jmsKeyFormatStrategy;
    }

    public void setJmsKeyFormatStrategy(
            JmsKeyFormatStrategy jmsKeyFormatStrategy) {
        this.jmsKeyFormatStrategy = jmsKeyFormatStrategy;
    }

    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }

    public QueueBrowseStrategy getQueueBrowseStrategy() {
        return queueBrowseStrategy;
    }

    public void setQueueBrowseStrategy(QueueBrowseStrategy queueBrowseStrategy) {
        this.queueBrowseStrategy = queueBrowseStrategy;
    }

    public HeaderFilterStrategy getHeaderFilterStrategy() {
        return headerFilterStrategy;
    }

    public void setHeaderFilterStrategy(
            HeaderFilterStrategy headerFilterStrategy) {
        this.headerFilterStrategy = headerFilterStrategy;
    }

    public MessageCreatedStrategy getMessageCreatedStrategy() {
        return messageCreatedStrategy;
    }

    public void setMessageCreatedStrategy(
            MessageCreatedStrategy messageCreatedStrategy) {
        this.messageCreatedStrategy = messageCreatedStrategy;
    }

    public int getWaitForProvisionCorrelationToBeUpdatedCounter() {
        return waitForProvisionCorrelationToBeUpdatedCounter;
    }

    public void setWaitForProvisionCorrelationToBeUpdatedCounter(
            int waitForProvisionCorrelationToBeUpdatedCounter) {
        this.waitForProvisionCorrelationToBeUpdatedCounter = waitForProvisionCorrelationToBeUpdatedCounter;
    }

    public long getWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime() {
        return waitForProvisionCorrelationToBeUpdatedThreadSleepingTime;
    }

    public void setWaitForProvisionCorrelationToBeUpdatedThreadSleepingTime(
            long waitForProvisionCorrelationToBeUpdatedThreadSleepingTime) {
        this.waitForProvisionCorrelationToBeUpdatedThreadSleepingTime = waitForProvisionCorrelationToBeUpdatedThreadSleepingTime;
    }
}